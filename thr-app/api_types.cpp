/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "pch.h"
#include "api_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace api {


Amount::~Amount() throw() {
}


void Amount::__set_integral(const int32_t val) {
  this->integral = val;
}

void Amount::__set_fraction(const int64_t val) {
  this->fraction = val;
}
std::ostream& operator<<(std::ostream& out, const Amount& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Amount::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_integral = false;
  bool isset_fraction = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->integral);
          isset_integral = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fraction);
          isset_fraction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_integral)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fraction)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Amount::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Amount");

  xfer += oprot->writeFieldBegin("integral", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->integral);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fraction", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->fraction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Amount &a, Amount &b) {
  using ::std::swap;
  swap(a.integral, b.integral);
  swap(a.fraction, b.fraction);
}

Amount::Amount(const Amount& other0) {
  integral = other0.integral;
  fraction = other0.fraction;
}
Amount& Amount::operator=(const Amount& other1) {
  integral = other1.integral;
  fraction = other1.fraction;
  return *this;
}
void Amount::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Amount(";
  out << "integral=" << to_string(integral);
  out << ", " << "fraction=" << to_string(fraction);
  out << ")";
}


CumulativeAmount::~CumulativeAmount() throw() {
}


void CumulativeAmount::__set_integral(const int64_t val) {
  this->integral = val;
}

void CumulativeAmount::__set_fraction(const int64_t val) {
  this->fraction = val;
}
std::ostream& operator<<(std::ostream& out, const CumulativeAmount& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CumulativeAmount::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_integral = false;
  bool isset_fraction = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->integral);
          isset_integral = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fraction);
          isset_fraction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_integral)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fraction)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CumulativeAmount::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CumulativeAmount");

  xfer += oprot->writeFieldBegin("integral", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->integral);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fraction", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->fraction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CumulativeAmount &a, CumulativeAmount &b) {
  using ::std::swap;
  swap(a.integral, b.integral);
  swap(a.fraction, b.fraction);
}

CumulativeAmount::CumulativeAmount(const CumulativeAmount& other2) {
  integral = other2.integral;
  fraction = other2.fraction;
}
CumulativeAmount& CumulativeAmount::operator=(const CumulativeAmount& other3) {
  integral = other3.integral;
  fraction = other3.fraction;
  return *this;
}
void CumulativeAmount::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CumulativeAmount(";
  out << "integral=" << to_string(integral);
  out << ", " << "fraction=" << to_string(fraction);
  out << ")";
}


SmartContract::~SmartContract() throw() {
}


void SmartContract::__set_address(const Address& val) {
  this->address = val;
}

void SmartContract::__set_deployer(const Address& val) {
  this->deployer = val;
}

void SmartContract::__set_sourceCode(const std::string& val) {
  this->sourceCode = val;
}

void SmartContract::__set_byteCode(const std::string& val) {
  this->byteCode = val;
}

void SmartContract::__set_hashState(const std::string& val) {
  this->hashState = val;
}
std::ostream& operator<<(std::ostream& out, const SmartContract& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContract::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_address = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->address);
          isset_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->deployer);
          this->__isset.deployer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sourceCode);
          this->__isset.sourceCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->byteCode);
          this->__isset.byteCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hashState);
          this->__isset.hashState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_address)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SmartContract::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContract");

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->address);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deployer", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->deployer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sourceCode", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->sourceCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteCode", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->byteCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hashState", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->hashState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContract &a, SmartContract &b) {
  using ::std::swap;
  swap(a.address, b.address);
  swap(a.deployer, b.deployer);
  swap(a.sourceCode, b.sourceCode);
  swap(a.byteCode, b.byteCode);
  swap(a.hashState, b.hashState);
  swap(a.__isset, b.__isset);
}

SmartContract::SmartContract(const SmartContract& other4) {
  address = other4.address;
  deployer = other4.deployer;
  sourceCode = other4.sourceCode;
  byteCode = other4.byteCode;
  hashState = other4.hashState;
  __isset = other4.__isset;
}
SmartContract& SmartContract::operator=(const SmartContract& other5) {
  address = other5.address;
  deployer = other5.deployer;
  sourceCode = other5.sourceCode;
  byteCode = other5.byteCode;
  hashState = other5.hashState;
  __isset = other5.__isset;
  return *this;
}
void SmartContract::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContract(";
  out << "address=" << to_string(address);
  out << ", " << "deployer=" << to_string(deployer);
  out << ", " << "sourceCode=" << to_string(sourceCode);
  out << ", " << "byteCode=" << to_string(byteCode);
  out << ", " << "hashState=" << to_string(hashState);
  out << ")";
}


SmartContractInvocation::~SmartContractInvocation() throw() {
}


void SmartContractInvocation::__set_sourceCode(const std::string& val) {
  this->sourceCode = val;
}

void SmartContractInvocation::__set_byteCode(const std::string& val) {
  this->byteCode = val;
}

void SmartContractInvocation::__set_hashState(const std::string& val) {
  this->hashState = val;
}

void SmartContractInvocation::__set_method(const std::string& val) {
  this->method = val;
}

void SmartContractInvocation::__set_params(const std::vector<std::string> & val) {
  this->params = val;
}

void SmartContractInvocation::__set_forgetNewState(const bool val) {
  this->forgetNewState = val;
}
std::ostream& operator<<(std::ostream& out, const SmartContractInvocation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContractInvocation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sourceCode);
          this->__isset.sourceCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->byteCode);
          this->__isset.byteCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hashState);
          this->__isset.hashState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method);
          this->__isset.method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->params.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->params.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readString(this->params[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->forgetNewState);
          this->__isset.forgetNewState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartContractInvocation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContractInvocation");

  xfer += oprot->writeFieldBegin("sourceCode", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sourceCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteCode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->byteCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hashState", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->hashState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->params.size()));
    std::vector<std::string> ::const_iterator _iter11;
    for (_iter11 = this->params.begin(); _iter11 != this->params.end(); ++_iter11)
    {
      xfer += oprot->writeString((*_iter11));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("forgetNewState", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->forgetNewState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContractInvocation &a, SmartContractInvocation &b) {
  using ::std::swap;
  swap(a.sourceCode, b.sourceCode);
  swap(a.byteCode, b.byteCode);
  swap(a.hashState, b.hashState);
  swap(a.method, b.method);
  swap(a.params, b.params);
  swap(a.forgetNewState, b.forgetNewState);
  swap(a.__isset, b.__isset);
}

SmartContractInvocation::SmartContractInvocation(const SmartContractInvocation& other12) {
  sourceCode = other12.sourceCode;
  byteCode = other12.byteCode;
  hashState = other12.hashState;
  method = other12.method;
  params = other12.params;
  forgetNewState = other12.forgetNewState;
  __isset = other12.__isset;
}
SmartContractInvocation& SmartContractInvocation::operator=(const SmartContractInvocation& other13) {
  sourceCode = other13.sourceCode;
  byteCode = other13.byteCode;
  hashState = other13.hashState;
  method = other13.method;
  params = other13.params;
  forgetNewState = other13.forgetNewState;
  __isset = other13.__isset;
  return *this;
}
void SmartContractInvocation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContractInvocation(";
  out << "sourceCode=" << to_string(sourceCode);
  out << ", " << "byteCode=" << to_string(byteCode);
  out << ", " << "hashState=" << to_string(hashState);
  out << ", " << "method=" << to_string(method);
  out << ", " << "params=" << to_string(params);
  out << ", " << "forgetNewState=" << to_string(forgetNewState);
  out << ")";
}


TransactionId::~TransactionId() throw() {
}


void TransactionId::__set_poolHash(const PoolHash& val) {
  this->poolHash = val;
}

void TransactionId::__set_index(const int32_t val) {
  this->index = val;
}
std::ostream& operator<<(std::ostream& out, const TransactionId& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TransactionId::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->poolHash);
          this->__isset.poolHash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TransactionId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TransactionId");

  xfer += oprot->writeFieldBegin("poolHash", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->poolHash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransactionId &a, TransactionId &b) {
  using ::std::swap;
  swap(a.poolHash, b.poolHash);
  swap(a.index, b.index);
  swap(a.__isset, b.__isset);
}

TransactionId::TransactionId(const TransactionId& other14) {
  poolHash = other14.poolHash;
  index = other14.index;
  __isset = other14.__isset;
}
TransactionId& TransactionId::operator=(const TransactionId& other15) {
  poolHash = other15.poolHash;
  index = other15.index;
  __isset = other15.__isset;
  return *this;
}
void TransactionId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TransactionId(";
  out << "poolHash=" << to_string(poolHash);
  out << ", " << "index=" << to_string(index);
  out << ")";
}


Transaction::~Transaction() throw() {
}


void Transaction::__set_id(const int64_t val) {
  this->id = val;
}

void Transaction::__set_source(const Address& val) {
  this->source = val;
}

void Transaction::__set_target(const Address& val) {
  this->target = val;
}

void Transaction::__set_amount(const Amount& val) {
  this->amount = val;
}

void Transaction::__set_balance(const Amount& val) {
  this->balance = val;
}

void Transaction::__set_currency(const Currency val) {
  this->currency = val;
}

void Transaction::__set_signature(const std::string& val) {
  this->signature = val;
}

void Transaction::__set_smartContract(const SmartContractInvocation& val) {
  this->smartContract = val;
__isset.smartContract = true;
}

void Transaction::__set_fee(const Amount& val) {
  this->fee = val;
}
std::ostream& operator<<(std::ostream& out, const Transaction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Transaction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->source);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->target);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->amount.read(iprot);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->balance.read(iprot);
          this->__isset.balance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->currency);
          this->__isset.currency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->smartContract.read(iprot);
          this->__isset.smartContract = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fee.read(iprot);
          this->__isset.fee = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Transaction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Transaction");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->source);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->amount.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("balance", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->balance.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currency", ::apache::thrift::protocol::T_BYTE, 6);
  xfer += oprot->writeByte(this->currency);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeBinary(this->signature);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.smartContract) {
    xfer += oprot->writeFieldBegin("smartContract", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->smartContract.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("fee", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->fee.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Transaction &a, Transaction &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.source, b.source);
  swap(a.target, b.target);
  swap(a.amount, b.amount);
  swap(a.balance, b.balance);
  swap(a.currency, b.currency);
  swap(a.signature, b.signature);
  swap(a.smartContract, b.smartContract);
  swap(a.fee, b.fee);
  swap(a.__isset, b.__isset);
}

Transaction::Transaction(const Transaction& other16) {
  id = other16.id;
  source = other16.source;
  target = other16.target;
  amount = other16.amount;
  balance = other16.balance;
  currency = other16.currency;
  signature = other16.signature;
  smartContract = other16.smartContract;
  fee = other16.fee;
  __isset = other16.__isset;
}
Transaction& Transaction::operator=(const Transaction& other17) {
  id = other17.id;
  source = other17.source;
  target = other17.target;
  amount = other17.amount;
  balance = other17.balance;
  currency = other17.currency;
  signature = other17.signature;
  smartContract = other17.smartContract;
  fee = other17.fee;
  __isset = other17.__isset;
  return *this;
}
void Transaction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Transaction(";
  out << "id=" << to_string(id);
  out << ", " << "source=" << to_string(source);
  out << ", " << "target=" << to_string(target);
  out << ", " << "amount=" << to_string(amount);
  out << ", " << "balance=" << to_string(balance);
  out << ", " << "currency=" << to_string(currency);
  out << ", " << "signature=" << to_string(signature);
  out << ", " << "smartContract="; (__isset.smartContract ? (out << to_string(smartContract)) : (out << "<null>"));
  out << ", " << "fee=" << to_string(fee);
  out << ")";
}


SealedTransaction::~SealedTransaction() throw() {
}


void SealedTransaction::__set_id(const TransactionId& val) {
  this->id = val;
}

void SealedTransaction::__set_trxn(const Transaction& val) {
  this->trxn = val;
}
std::ostream& operator<<(std::ostream& out, const SealedTransaction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SealedTransaction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id.read(iprot);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->trxn.read(iprot);
          this->__isset.trxn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SealedTransaction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SealedTransaction");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("trxn", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->trxn.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SealedTransaction &a, SealedTransaction &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.trxn, b.trxn);
  swap(a.__isset, b.__isset);
}

SealedTransaction::SealedTransaction(const SealedTransaction& other18) {
  id = other18.id;
  trxn = other18.trxn;
  __isset = other18.__isset;
}
SealedTransaction& SealedTransaction::operator=(const SealedTransaction& other19) {
  id = other19.id;
  trxn = other19.trxn;
  __isset = other19.__isset;
  return *this;
}
void SealedTransaction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SealedTransaction(";
  out << "id=" << to_string(id);
  out << ", " << "trxn=" << to_string(trxn);
  out << ")";
}


Pool::~Pool() throw() {
}


void Pool::__set_hash(const PoolHash& val) {
  this->hash = val;
}

void Pool::__set_prevHash(const PoolHash& val) {
  this->prevHash = val;
}

void Pool::__set_time(const Time val) {
  this->time = val;
}

void Pool::__set_transactionsCount(const int32_t val) {
  this->transactionsCount = val;
}

void Pool::__set_poolNumber(const PoolNumber val) {
  this->poolNumber = val;
}
std::ostream& operator<<(std::ostream& out, const Pool& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Pool::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->hash);
          this->__isset.hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->prevHash);
          this->__isset.prevHash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->transactionsCount);
          this->__isset.transactionsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->poolNumber);
          this->__isset.poolNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Pool::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Pool");

  xfer += oprot->writeFieldBegin("hash", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prevHash", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->prevHash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactionsCount", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->transactionsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poolNumber", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->poolNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Pool &a, Pool &b) {
  using ::std::swap;
  swap(a.hash, b.hash);
  swap(a.prevHash, b.prevHash);
  swap(a.time, b.time);
  swap(a.transactionsCount, b.transactionsCount);
  swap(a.poolNumber, b.poolNumber);
  swap(a.__isset, b.__isset);
}

Pool::Pool(const Pool& other20) {
  hash = other20.hash;
  prevHash = other20.prevHash;
  time = other20.time;
  transactionsCount = other20.transactionsCount;
  poolNumber = other20.poolNumber;
  __isset = other20.__isset;
}
Pool& Pool::operator=(const Pool& other21) {
  hash = other21.hash;
  prevHash = other21.prevHash;
  time = other21.time;
  transactionsCount = other21.transactionsCount;
  poolNumber = other21.poolNumber;
  __isset = other21.__isset;
  return *this;
}
void Pool::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Pool(";
  out << "hash=" << to_string(hash);
  out << ", " << "prevHash=" << to_string(prevHash);
  out << ", " << "time=" << to_string(time);
  out << ", " << "transactionsCount=" << to_string(transactionsCount);
  out << ", " << "poolNumber=" << to_string(poolNumber);
  out << ")";
}


PeriodStats::~PeriodStats() throw() {
}


void PeriodStats::__set_periodDuration(const Time val) {
  this->periodDuration = val;
}

void PeriodStats::__set_poolsCount(const Count val) {
  this->poolsCount = val;
}

void PeriodStats::__set_transactionsCount(const Count val) {
  this->transactionsCount = val;
}

void PeriodStats::__set_balancePerCurrency(const Total& val) {
  this->balancePerCurrency = val;
}

void PeriodStats::__set_smartContractsCount(const Count val) {
  this->smartContractsCount = val;
}

void PeriodStats::__set_transactionsSmartCount(const Count val) {
  this->transactionsSmartCount = val;
}
std::ostream& operator<<(std::ostream& out, const PeriodStats& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PeriodStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->periodDuration);
          this->__isset.periodDuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->poolsCount);
          this->__isset.poolsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->transactionsCount);
          this->__isset.transactionsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->balancePerCurrency.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _ktype23;
            ::apache::thrift::protocol::TType _vtype24;
            xfer += iprot->readMapBegin(_ktype23, _vtype24, _size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              Currency _key27;
              xfer += iprot->readByte(_key27);
              CumulativeAmount& _val28 = this->balancePerCurrency[_key27];
              xfer += _val28.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.balancePerCurrency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->smartContractsCount);
          this->__isset.smartContractsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->transactionsSmartCount);
          this->__isset.transactionsSmartCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PeriodStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PeriodStats");

  xfer += oprot->writeFieldBegin("periodDuration", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->periodDuration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poolsCount", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->poolsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactionsCount", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->transactionsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("balancePerCurrency", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_BYTE, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->balancePerCurrency.size()));
    std::map<Currency, CumulativeAmount> ::const_iterator _iter29;
    for (_iter29 = this->balancePerCurrency.begin(); _iter29 != this->balancePerCurrency.end(); ++_iter29)
    {
      xfer += oprot->writeByte(_iter29->first);
      xfer += _iter29->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("smartContractsCount", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->smartContractsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactionsSmartCount", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->transactionsSmartCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PeriodStats &a, PeriodStats &b) {
  using ::std::swap;
  swap(a.periodDuration, b.periodDuration);
  swap(a.poolsCount, b.poolsCount);
  swap(a.transactionsCount, b.transactionsCount);
  swap(a.balancePerCurrency, b.balancePerCurrency);
  swap(a.smartContractsCount, b.smartContractsCount);
  swap(a.transactionsSmartCount, b.transactionsSmartCount);
  swap(a.__isset, b.__isset);
}

PeriodStats::PeriodStats(const PeriodStats& other30) {
  periodDuration = other30.periodDuration;
  poolsCount = other30.poolsCount;
  transactionsCount = other30.transactionsCount;
  balancePerCurrency = other30.balancePerCurrency;
  smartContractsCount = other30.smartContractsCount;
  transactionsSmartCount = other30.transactionsSmartCount;
  __isset = other30.__isset;
}
PeriodStats& PeriodStats::operator=(const PeriodStats& other31) {
  periodDuration = other31.periodDuration;
  poolsCount = other31.poolsCount;
  transactionsCount = other31.transactionsCount;
  balancePerCurrency = other31.balancePerCurrency;
  smartContractsCount = other31.smartContractsCount;
  transactionsSmartCount = other31.transactionsSmartCount;
  __isset = other31.__isset;
  return *this;
}
void PeriodStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PeriodStats(";
  out << "periodDuration=" << to_string(periodDuration);
  out << ", " << "poolsCount=" << to_string(poolsCount);
  out << ", " << "transactionsCount=" << to_string(transactionsCount);
  out << ", " << "balancePerCurrency=" << to_string(balancePerCurrency);
  out << ", " << "smartContractsCount=" << to_string(smartContractsCount);
  out << ", " << "transactionsSmartCount=" << to_string(transactionsSmartCount);
  out << ")";
}


APIResponse::~APIResponse() throw() {
}


void APIResponse::__set_code(const int8_t val) {
  this->code = val;
}

void APIResponse::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const APIResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t APIResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t APIResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("APIResponse");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(APIResponse &a, APIResponse &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

APIResponse::APIResponse(const APIResponse& other32) {
  code = other32.code;
  message = other32.message;
  __isset = other32.__isset;
}
APIResponse& APIResponse::operator=(const APIResponse& other33) {
  code = other33.code;
  message = other33.message;
  __isset = other33.__isset;
  return *this;
}
void APIResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "APIResponse(";
  out << "code=" << to_string(code);
  out << ", " << "message=" << to_string(message);
  out << ")";
}


BalanceGetResult::~BalanceGetResult() throw() {
}


void BalanceGetResult::__set_status(const APIResponse& val) {
  this->status = val;
}

void BalanceGetResult::__set_amount(const Amount& val) {
  this->amount = val;
}
std::ostream& operator<<(std::ostream& out, const BalanceGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BalanceGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->amount.read(iprot);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BalanceGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BalanceGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->amount.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BalanceGetResult &a, BalanceGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.amount, b.amount);
  swap(a.__isset, b.__isset);
}

BalanceGetResult::BalanceGetResult(const BalanceGetResult& other34) {
  status = other34.status;
  amount = other34.amount;
  __isset = other34.__isset;
}
BalanceGetResult& BalanceGetResult::operator=(const BalanceGetResult& other35) {
  status = other35.status;
  amount = other35.amount;
  __isset = other35.__isset;
  return *this;
}
void BalanceGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BalanceGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "amount=" << to_string(amount);
  out << ")";
}


TransactionGetResult::~TransactionGetResult() throw() {
}


void TransactionGetResult::__set_status(const APIResponse& val) {
  this->status = val;
}

void TransactionGetResult::__set_found(const bool val) {
  this->found = val;
}

void TransactionGetResult::__set_transaction(const SealedTransaction& val) {
  this->transaction = val;
}
std::ostream& operator<<(std::ostream& out, const TransactionGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TransactionGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->found);
          this->__isset.found = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transaction.read(iprot);
          this->__isset.transaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TransactionGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TransactionGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("found", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->found);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transaction", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->transaction.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransactionGetResult &a, TransactionGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.found, b.found);
  swap(a.transaction, b.transaction);
  swap(a.__isset, b.__isset);
}

TransactionGetResult::TransactionGetResult(const TransactionGetResult& other36) {
  status = other36.status;
  found = other36.found;
  transaction = other36.transaction;
  __isset = other36.__isset;
}
TransactionGetResult& TransactionGetResult::operator=(const TransactionGetResult& other37) {
  status = other37.status;
  found = other37.found;
  transaction = other37.transaction;
  __isset = other37.__isset;
  return *this;
}
void TransactionGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TransactionGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "found=" << to_string(found);
  out << ", " << "transaction=" << to_string(transaction);
  out << ")";
}


TransactionsGetResult::~TransactionsGetResult() throw() {
}


void TransactionsGetResult::__set_status(const APIResponse& val) {
  this->status = val;
}

void TransactionsGetResult::__set_result(const bool val) {
  this->result = val;
}

void TransactionsGetResult::__set_transactions(const std::vector<SealedTransaction> & val) {
  this->transactions = val;
}
std::ostream& operator<<(std::ostream& out, const TransactionsGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TransactionsGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->transactions.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->transactions.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += this->transactions[_i42].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.transactions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TransactionsGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TransactionsGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactions", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->transactions.size()));
    std::vector<SealedTransaction> ::const_iterator _iter43;
    for (_iter43 = this->transactions.begin(); _iter43 != this->transactions.end(); ++_iter43)
    {
      xfer += (*_iter43).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransactionsGetResult &a, TransactionsGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.result, b.result);
  swap(a.transactions, b.transactions);
  swap(a.__isset, b.__isset);
}

TransactionsGetResult::TransactionsGetResult(const TransactionsGetResult& other44) {
  status = other44.status;
  result = other44.result;
  transactions = other44.transactions;
  __isset = other44.__isset;
}
TransactionsGetResult& TransactionsGetResult::operator=(const TransactionsGetResult& other45) {
  status = other45.status;
  result = other45.result;
  transactions = other45.transactions;
  __isset = other45.__isset;
  return *this;
}
void TransactionsGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TransactionsGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "result=" << to_string(result);
  out << ", " << "transactions=" << to_string(transactions);
  out << ")";
}


TransactionFlowResult::~TransactionFlowResult() throw() {
}


void TransactionFlowResult::__set_status(const APIResponse& val) {
  this->status = val;
}

void TransactionFlowResult::__set_smart_contract_result(const  ::variant::Variant& val) {
  this->smart_contract_result = val;
__isset.smart_contract_result = true;
}
std::ostream& operator<<(std::ostream& out, const TransactionFlowResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TransactionFlowResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->smart_contract_result.read(iprot);
          this->__isset.smart_contract_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TransactionFlowResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TransactionFlowResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.smart_contract_result) {
    xfer += oprot->writeFieldBegin("smart_contract_result", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->smart_contract_result.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransactionFlowResult &a, TransactionFlowResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.smart_contract_result, b.smart_contract_result);
  swap(a.__isset, b.__isset);
}

TransactionFlowResult::TransactionFlowResult(const TransactionFlowResult& other46) {
  status = other46.status;
  smart_contract_result = other46.smart_contract_result;
  __isset = other46.__isset;
}
TransactionFlowResult& TransactionFlowResult::operator=(const TransactionFlowResult& other47) {
  status = other47.status;
  smart_contract_result = other47.smart_contract_result;
  __isset = other47.__isset;
  return *this;
}
void TransactionFlowResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TransactionFlowResult(";
  out << "status=" << to_string(status);
  out << ", " << "smart_contract_result="; (__isset.smart_contract_result ? (out << to_string(smart_contract_result)) : (out << "<null>"));
  out << ")";
}


PoolListGetResult::~PoolListGetResult() throw() {
}


void PoolListGetResult::__set_status(const APIResponse& val) {
  this->status = val;
}

void PoolListGetResult::__set_result(const bool val) {
  this->result = val;
}

void PoolListGetResult::__set_pools(const std::vector<Pool> & val) {
  this->pools = val;
}
std::ostream& operator<<(std::ostream& out, const PoolListGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PoolListGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pools.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->pools.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += this->pools[_i52].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.pools = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PoolListGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PoolListGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pools", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pools.size()));
    std::vector<Pool> ::const_iterator _iter53;
    for (_iter53 = this->pools.begin(); _iter53 != this->pools.end(); ++_iter53)
    {
      xfer += (*_iter53).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PoolListGetResult &a, PoolListGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.result, b.result);
  swap(a.pools, b.pools);
  swap(a.__isset, b.__isset);
}

PoolListGetResult::PoolListGetResult(const PoolListGetResult& other54) {
  status = other54.status;
  result = other54.result;
  pools = other54.pools;
  __isset = other54.__isset;
}
PoolListGetResult& PoolListGetResult::operator=(const PoolListGetResult& other55) {
  status = other55.status;
  result = other55.result;
  pools = other55.pools;
  __isset = other55.__isset;
  return *this;
}
void PoolListGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PoolListGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "result=" << to_string(result);
  out << ", " << "pools=" << to_string(pools);
  out << ")";
}


PoolInfoGetResult::~PoolInfoGetResult() throw() {
}


void PoolInfoGetResult::__set_status(const APIResponse& val) {
  this->status = val;
}

void PoolInfoGetResult::__set_isFound(const bool val) {
  this->isFound = val;
}

void PoolInfoGetResult::__set_pool(const Pool& val) {
  this->pool = val;
}
std::ostream& operator<<(std::ostream& out, const PoolInfoGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PoolInfoGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isFound);
          this->__isset.isFound = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pool.read(iprot);
          this->__isset.pool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PoolInfoGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PoolInfoGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isFound", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isFound);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pool", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->pool.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PoolInfoGetResult &a, PoolInfoGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.isFound, b.isFound);
  swap(a.pool, b.pool);
  swap(a.__isset, b.__isset);
}

PoolInfoGetResult::PoolInfoGetResult(const PoolInfoGetResult& other56) {
  status = other56.status;
  isFound = other56.isFound;
  pool = other56.pool;
  __isset = other56.__isset;
}
PoolInfoGetResult& PoolInfoGetResult::operator=(const PoolInfoGetResult& other57) {
  status = other57.status;
  isFound = other57.isFound;
  pool = other57.pool;
  __isset = other57.__isset;
  return *this;
}
void PoolInfoGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PoolInfoGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "isFound=" << to_string(isFound);
  out << ", " << "pool=" << to_string(pool);
  out << ")";
}


PoolTransactionsGetResult::~PoolTransactionsGetResult() throw() {
}


void PoolTransactionsGetResult::__set_status(const APIResponse& val) {
  this->status = val;
}

void PoolTransactionsGetResult::__set_transactions(const std::vector<SealedTransaction> & val) {
  this->transactions = val;
}
std::ostream& operator<<(std::ostream& out, const PoolTransactionsGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PoolTransactionsGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->transactions.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readListBegin(_etype61, _size58);
            this->transactions.resize(_size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              xfer += this->transactions[_i62].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.transactions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PoolTransactionsGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PoolTransactionsGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->transactions.size()));
    std::vector<SealedTransaction> ::const_iterator _iter63;
    for (_iter63 = this->transactions.begin(); _iter63 != this->transactions.end(); ++_iter63)
    {
      xfer += (*_iter63).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PoolTransactionsGetResult &a, PoolTransactionsGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.transactions, b.transactions);
  swap(a.__isset, b.__isset);
}

PoolTransactionsGetResult::PoolTransactionsGetResult(const PoolTransactionsGetResult& other64) {
  status = other64.status;
  transactions = other64.transactions;
  __isset = other64.__isset;
}
PoolTransactionsGetResult& PoolTransactionsGetResult::operator=(const PoolTransactionsGetResult& other65) {
  status = other65.status;
  transactions = other65.transactions;
  __isset = other65.__isset;
  return *this;
}
void PoolTransactionsGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PoolTransactionsGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "transactions=" << to_string(transactions);
  out << ")";
}


StatsGetResult::~StatsGetResult() throw() {
}


void StatsGetResult::__set_status(const APIResponse& val) {
  this->status = val;
}

void StatsGetResult::__set_stats(const StatsPerPeriod& val) {
  this->stats = val;
}
std::ostream& operator<<(std::ostream& out, const StatsGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StatsGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stats.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _etype69;
            xfer += iprot->readListBegin(_etype69, _size66);
            this->stats.resize(_size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              xfer += this->stats[_i70].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StatsGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StatsGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stats", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->stats.size()));
    std::vector<PeriodStats> ::const_iterator _iter71;
    for (_iter71 = this->stats.begin(); _iter71 != this->stats.end(); ++_iter71)
    {
      xfer += (*_iter71).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StatsGetResult &a, StatsGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.stats, b.stats);
  swap(a.__isset, b.__isset);
}

StatsGetResult::StatsGetResult(const StatsGetResult& other72) {
  status = other72.status;
  stats = other72.stats;
  __isset = other72.__isset;
}
StatsGetResult& StatsGetResult::operator=(const StatsGetResult& other73) {
  status = other73.status;
  stats = other73.stats;
  __isset = other73.__isset;
  return *this;
}
void StatsGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StatsGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "stats=" << to_string(stats);
  out << ")";
}


SmartContractGetResult::~SmartContractGetResult() throw() {
}


void SmartContractGetResult::__set_status(const APIResponse& val) {
  this->status = val;
}

void SmartContractGetResult::__set_smartContract(const SmartContract& val) {
  this->smartContract = val;
}
std::ostream& operator<<(std::ostream& out, const SmartContractGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContractGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->smartContract.read(iprot);
          this->__isset.smartContract = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartContractGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContractGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("smartContract", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->smartContract.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContractGetResult &a, SmartContractGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.smartContract, b.smartContract);
  swap(a.__isset, b.__isset);
}

SmartContractGetResult::SmartContractGetResult(const SmartContractGetResult& other74) {
  status = other74.status;
  smartContract = other74.smartContract;
  __isset = other74.__isset;
}
SmartContractGetResult& SmartContractGetResult::operator=(const SmartContractGetResult& other75) {
  status = other75.status;
  smartContract = other75.smartContract;
  __isset = other75.__isset;
  return *this;
}
void SmartContractGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContractGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "smartContract=" << to_string(smartContract);
  out << ")";
}


SmartContractAddressesListGetResult::~SmartContractAddressesListGetResult() throw() {
}


void SmartContractAddressesListGetResult::__set_status(const APIResponse& val) {
  this->status = val;
}

void SmartContractAddressesListGetResult::__set_addressesList(const std::vector<Address> & val) {
  this->addressesList = val;
}
std::ostream& operator<<(std::ostream& out, const SmartContractAddressesListGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContractAddressesListGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->addressesList.clear();
            uint32_t _size76;
            ::apache::thrift::protocol::TType _etype79;
            xfer += iprot->readListBegin(_etype79, _size76);
            this->addressesList.resize(_size76);
            uint32_t _i80;
            for (_i80 = 0; _i80 < _size76; ++_i80)
            {
              xfer += iprot->readBinary(this->addressesList[_i80]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.addressesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartContractAddressesListGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContractAddressesListGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addressesList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->addressesList.size()));
    std::vector<Address> ::const_iterator _iter81;
    for (_iter81 = this->addressesList.begin(); _iter81 != this->addressesList.end(); ++_iter81)
    {
      xfer += oprot->writeBinary((*_iter81));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContractAddressesListGetResult &a, SmartContractAddressesListGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.addressesList, b.addressesList);
  swap(a.__isset, b.__isset);
}

SmartContractAddressesListGetResult::SmartContractAddressesListGetResult(const SmartContractAddressesListGetResult& other82) {
  status = other82.status;
  addressesList = other82.addressesList;
  __isset = other82.__isset;
}
SmartContractAddressesListGetResult& SmartContractAddressesListGetResult::operator=(const SmartContractAddressesListGetResult& other83) {
  status = other83.status;
  addressesList = other83.addressesList;
  __isset = other83.__isset;
  return *this;
}
void SmartContractAddressesListGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContractAddressesListGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "addressesList=" << to_string(addressesList);
  out << ")";
}


SmartContractsListGetResult::~SmartContractsListGetResult() throw() {
}


void SmartContractsListGetResult::__set_status(const APIResponse& val) {
  this->status = val;
}

void SmartContractsListGetResult::__set_smartContractsList(const std::vector<SmartContract> & val) {
  this->smartContractsList = val;
}
std::ostream& operator<<(std::ostream& out, const SmartContractsListGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartContractsListGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->smartContractsList.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            xfer += iprot->readListBegin(_etype87, _size84);
            this->smartContractsList.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += this->smartContractsList[_i88].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.smartContractsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartContractsListGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartContractsListGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("smartContractsList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->smartContractsList.size()));
    std::vector<SmartContract> ::const_iterator _iter89;
    for (_iter89 = this->smartContractsList.begin(); _iter89 != this->smartContractsList.end(); ++_iter89)
    {
      xfer += (*_iter89).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartContractsListGetResult &a, SmartContractsListGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.smartContractsList, b.smartContractsList);
  swap(a.__isset, b.__isset);
}

SmartContractsListGetResult::SmartContractsListGetResult(const SmartContractsListGetResult& other90) {
  status = other90.status;
  smartContractsList = other90.smartContractsList;
  __isset = other90.__isset;
}
SmartContractsListGetResult& SmartContractsListGetResult::operator=(const SmartContractsListGetResult& other91) {
  status = other91.status;
  smartContractsList = other91.smartContractsList;
  __isset = other91.__isset;
  return *this;
}
void SmartContractsListGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartContractsListGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "smartContractsList=" << to_string(smartContractsList);
  out << ")";
}


SmartMethodParamsGetResult::~SmartMethodParamsGetResult() throw() {
}


void SmartMethodParamsGetResult::__set_status(const APIResponse& val) {
  this->status = val;
}

void SmartMethodParamsGetResult::__set_method(const std::string& val) {
  this->method = val;
}

void SmartMethodParamsGetResult::__set_params(const std::vector<std::string> & val) {
  this->params = val;
}
std::ostream& operator<<(std::ostream& out, const SmartMethodParamsGetResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SmartMethodParamsGetResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method);
          this->__isset.method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->params.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _etype95;
            xfer += iprot->readListBegin(_etype95, _size92);
            this->params.resize(_size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              xfer += iprot->readString(this->params[_i96]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SmartMethodParamsGetResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SmartMethodParamsGetResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->params.size()));
    std::vector<std::string> ::const_iterator _iter97;
    for (_iter97 = this->params.begin(); _iter97 != this->params.end(); ++_iter97)
    {
      xfer += oprot->writeString((*_iter97));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SmartMethodParamsGetResult &a, SmartMethodParamsGetResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.method, b.method);
  swap(a.params, b.params);
  swap(a.__isset, b.__isset);
}

SmartMethodParamsGetResult::SmartMethodParamsGetResult(const SmartMethodParamsGetResult& other98) {
  status = other98.status;
  method = other98.method;
  params = other98.params;
  __isset = other98.__isset;
}
SmartMethodParamsGetResult& SmartMethodParamsGetResult::operator=(const SmartMethodParamsGetResult& other99) {
  status = other99.status;
  method = other99.method;
  params = other99.params;
  __isset = other99.__isset;
  return *this;
}
void SmartMethodParamsGetResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SmartMethodParamsGetResult(";
  out << "status=" << to_string(status);
  out << ", " << "method=" << to_string(method);
  out << ", " << "params=" << to_string(params);
  out << ")";
}

} // namespace
